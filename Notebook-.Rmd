---
title: "Coursera Genomic Data Science Capstone. Tobi Olanipekun Dec 2024"
output: 
  html_document:
    keep_md: true

---
Reads Retrieval and Galaxy Upload.

The Bioproject on NCBI's SRA Run selector can be located with the Bioproject number PRJNA245228.
Samples from 6 adults and 6 foetuses with the following sample run numbers were selected SRR1554537, SRR1554538, SRR1554541, SRR1554556, SRR1554561, SRR1554566, SRR1554345, SRR1554568, SRR1554567, SRR1554568, SRR1554345, SRR1554346, SRR1554347, SRR1554350 were selected, and reads were dumped/uploaded in to the Galaxy platform using the "Faster Download and Extract Reads in FASTQ format from NCBI SRA (Galaxy Version 3.1.1+galaxy1)"

The metadata file containing information for each samples was exported into an excel file from SRA runtool kit using the "Metadata" option after selecting the interested samples. Adult and Featal samples were identified using the age column and category of Adults as (20-50 years) and (<0 years) as Foetal.


Quality Control of the raw reads
I carried quality control on Galaxy using the FastQC tool (Galaxy Version 0.74+galaxy1)
I mapped the reads to the Human (Homo sapiens)(b38):hg38 genome using Galaxy's HISAT2 tool (Galaxy Version 2.2.1+galaxy1)

Summary of the average quality score per read and mapping alignment rate of each sample were summarised in the excel sheet for ease of further analysis





Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.


```{r Data retrieval and sample selection}

getwd()
setwd("C:/Users/olanipe3-INS/Downloads")

data <- read.table("Manifest with quality score and alignment rate age group excel.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
print(data)
```
there is much variation in the mapping quality testas it ranges from (99.80 to 80.74), therefore it is thought ful to confirm there is no statistical significance of the mapping quality amd average quality sacore of the two groups of samples. 

```{r t-test to compare average quality score}
# Subset adult and fetal groups
adult <- subset(data, Age.group == "adult")
fetal <- subset(data, Age.group == "fetal")

# Perform t-test for average quality score
quality_ttest <- t.test(adult$average_quality_score, fetal$average_quality_score)
cat("T-test results for average quality score:\n")
print(quality_ttest)
```
```{r t-test to compare mapping rate}
# Perform t-test for mapping rate
mapping_ttest <- t.test(adult$mapping_rate_HISAT, fetal$mapping_rate_HISAT)

cat("\nT-test results for mapping rate:\n")
print(mapping_ttest)
```
thee p value for the mapping rate is significantly diffferent across the groups and I had limited storage space to continue working with 12 samples,i decided to only keep the top 3 sample reads with the best mapping rates from each groups
```{r keeping better reads}
# Function to keep top N reads with best mapping rates for each group
keep_top_reads <- function(group_data, n = 3) {
  group_data[order(group_data$mapping_rate, decreasing = TRUE)[1:min(n, nrow(group_data))], ]
}

# Apply the function to each age group
top_reads <- do.call(rbind, lapply(split(data, data$Age.group), keep_top_reads))

# Print the resulting dataset
print(top_reads)
```
run the T test statistic again
```{r re-test to compare average quality score}
# Perform t-test for average quality score
#quality_ttest <- t.test(average_quality_score ~ Age.group, data = top_reads)
```
returns an error message becasue all the values for the quality score are the same "37"
```{r }
# Perform t-test for mapping rate
mapping_ttest <- t.test(mapping_rate_HISAT ~ Age.group, data = top_reads)

# Print results
cat("T-test results for average quality score:\n")
print(quality_ttest)

cat("\nT-test results for mapping rate:\n")
print(mapping_ttest)
```



write.table(top_reads, file = "top_reads.txt", sep = "\t", row.names = FALSE, quote = FALSE)


I used the gene count feature on galaxy to calculte the abundance of every gene in the selected sample, and then merged the resulting output together to get a single gene feature counts file that has counts of each genes in each of the 6 samples.

#see below
```{r Read the feature counts table}
merged_counts_file <- read.table("Genecounts file 06Dec2024.tabular", header = TRUE, row.names = 1, sep = "\t")

#change the column names to the names of the respective samples 
colnames(merged_counts_file) = c("SRR1554538","SRR1554556","SRR1554561","SRR1554566","SRR1554567","SRR2071347")
head(merged_counts_file)
```
```{r convert the ENSEMBLE Ids to gene names}
# Load necessary libraries
library(org.Hs.eg.db)
library(AnnotationDbi)

# Assuming your gene counts data frame is named 'counts'
# Extract Ensembl IDs from row names and remove version numbers
ensembl_ids <- sub("\\..*", "", sub(".*_", "", rownames(merged_counts_file)))

# Map Ensembl IDs to gene symbols
gene_symbols <- mapIds(org.Hs.eg.db,
                       keys = ensembl_ids,
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# Create new row names, using gene symbols where available and original names otherwise
new_rownames <- ifelse(is.na(gene_symbols),
                       sub("_.*", "", rownames(merged_counts_file)),
                       gene_symbols)

# Make the new row names unique
new_rownames <- make.unique(new_rownames)

# Assign the new row names to the counts data frame
rownames(merged_counts_file) <- new_rownames
head(merged_counts_file)
```
```{r unedited manifest file}
#Upload the manifest file downloaded from NCBI SRA tool kit

# Specify the path to your manifest file
manifest_file <- "Full_Manifest_File.tabular"

# Read the manifest file (adjust sep argument as needed)
Full_manifest <- read.table(manifest_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)

# Print the first few rows of the manifest to verify it has been loaded correctly
head(Full_manifest)
```
```{R subset manifest file to only contain the samples we are working with, i.e theones currently in the counts file}
# Load necessary libraries
library(dplyr)

# Subset the manifest file to include only those samples that are present in the counts data
# Check the column names of the counts data
count_samples <- colnames(merged_counts_file)

# Subset the manifest file to include only those samples that are present in the counts data
subset_manifest <- Full_manifest %>%
  dplyr::filter(Run %in% count_samples)

# Print the first few rows of the subsetted manifest
head(subset_manifest)
```
```{r rename new subset_manifest as "manifest" and merged_counts_file" as counts}

manifest <- subset_manifest
counts<- merged_counts_file
```

```{r add age group column to the manifest file}
manifest$Age_group <- ifelse(manifest$AGE < 0, "Fetal",
                               ifelse(manifest$AGE > 30, "Adult", NA))
# Print the first few rows of the updated manifest to verify
head(manifest)
```
```{r #change rownammes of metadata to sampleIDs and confirm it matches with the samples in counts file}
rownames(manifest) <-manifest$Run

#check if the number of columns of counts data matches the number of rows of metadata
all.equal(colnames(counts),rownames(manifest))
```
```{r exploratory Data analysis}
# Load necessary libraries
library(ggplot2)
library(reshape2)

# Assuming your counts data frame is named 'counts'
# Convert the counts data into a long format for ggplot2
counts_long <- melt(as.data.frame(counts), variable.name = "Sample", value.name = "Gene_Count")

# Apply log10 transformation to the counts (adding a small constant to avoid log(0))
counts_long$Log10_Count <- log10(counts_long$Gene_Count + 1)  # Adding 1 to avoid log(0)

# Create a boxplot to visualize the distribution of log-transformed counts across samples
ggplot(counts_long, aes(x = Sample, y = Log10_Count)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distribution of Log10 Transformed Gene Counts Across Samples",
       x = "Samples",
       y = "Log10 Gene Counts") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r lowly expressed genes across each sample}
#Visualising the percentage of lowly expressed genes across each sample
# Define the threshold for low expression
low_expression_threshold <- 5  # You can adjust this threshold as needed

# Calculate the number of lowly expressed genes for each sample
lowly_expressed_counts <- colSums(counts <= low_expression_threshold)

# Calculate the total number of genes for each sample
total_genes <- nrow(counts)

# Calculate the percentage of lowly expressed genes for each sample
percentage_lowly_expressed <- (lowly_expressed_counts / total_genes) * 100

# Convert to a data frame for ggplot
low_expression_df <- data.frame(Sample = names(percentage_lowly_expressed), 
                                Percentage_Lowly_Expressed = percentage_lowly_expressed)

# Create a barplot to visualize the percentage of lowly expressed genes across samples
ggplot(low_expression_df, aes(x = Sample, y = Percentage_Lowly_Expressed)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  labs(title = "Percentage of Lowly Expressed Genes Across Samples",
       x = "Samples",
       y = "Percentage of Lowly Expressed Genes (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#about more than 60% of lowly expressed genes, so will go with counts threshold of 5


```{r to Create a Barplot of Genes Detected Across Samples}
# Count the number of genes detected (non-zero counts) for each sample
genes_detected <- colSums(counts > 5)

# Convert to a data frame for ggplot
genes_detected_df <- data.frame(Sample = names(genes_detected), Genes_Detected = genes_detected)

# Create a barplot to visualize the number of genes detected across samples
ggplot(genes_detected_df, aes(x = Sample, y = Genes_Detected)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  labs(title = "Number of Genes Detected Across Samples",
       x = "Samples",
       y = "Number of Genes Detected") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

{barplot(rowSums(counts>5),xlab="Genes",ylab="Number of samples",las=2,names.arg="")
  abline(h=median(rowSums(counts>5)))}

```{r Visualising the detection rate of genes }
#Visualising the detection rate of genes
# Calculate the detection rate for each gene
detection_rates <- rowSums(counts > 5)  # Percentage of samples where the gene is detected

# Convert to a data frame for ggplot
detection_rates_df <- data.frame(Gene = rownames(counts), Detection_Rate = detection_rates)

# Create a barplot to visualize the detection rates across genes
ggplot(detection_rates_df, aes(x = reorder(Gene, Detection_Rate), y = Detection_Rate)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  labs(title = "Detection Rates Across Genes",
       x = "Genes",
       y = "Detection Rate (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_flip()  # Flip coordinates for better readability
```
```{r discard lowly expressed genes}
#Many of the genes are not detected in most of the samples, so I will be discarding samples that are not expressed in atleast 50% of the samples
#To discard genes that are not expressed in atleast 50% of the samples
# Calculate total counts for each sample
total_counts <- colSums(counts)

# Calculate CPM for each gene
cpm <- t(t(counts) / total_counts) * 1e6  # Transpose to divide each count by the total counts and multiply by 1e6

# Define a threshold for CPM below which genes will be discarded
cpm_threshold <- 1  # You can adjust this threshold as needed

# Identify genes that are detected (CPM > threshold) in at least a certain number of samples
min_samples_detected <- 0.5 * ncol(counts)  # At least 50% of samples

# Create a logical vector for genes to keep
genes_to_keep <- rowSums(cpm > cpm_threshold) >= min_samples_detected

# Subset the counts data frame to keep only the genes that meet the criteria
filtered_counts <- counts[genes_to_keep, ]

# Print the number of genes retained and discarded
cat("Number of genes retained:", nrow(filtered_counts), "\n")
cat("Number of genes discarded:", nrow(counts) - nrow(filtered_counts), "\n")
```
```{r visualising after removing lowly expressed genes}
# Assuming 'filtered_counts' is your data frame containing the retained genes
# Convert the filtered counts data into a long format for ggplot2
filtered_counts_long <- melt(as.data.frame(filtered_counts), variable.name = "Sample", value.name = "Gene_Count")

# Apply log10 transformation to the counts (adding a small constant to avoid log(0))
filtered_counts_long$Log10_Count <- log10(filtered_counts_long$Gene_Count + 1)  # Adding 1 to avoid log(0)

# Create a boxplot to visualize the distribution of log-transformed counts across samples
ggplot(filtered_counts_long, aes(x = Sample, y = Log10_Count)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distribution of Log10 Transformed Gene Counts for Kept Genes Across Samples",
       x = "Samples",
       y = "Log10 Gene Counts") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
The gene counts across looks better comparable across the samples now
```{R #DESeq2 normalisation}
#Load necessary libraries
library(DESeq2)

# Create a DESeqDataSet object using the filtered counts fr
dds <- DESeqDataSetFromMatrix(countData = filtered_counts,
                              colData = manifest,
                              design = ~ Age_group)  # Adjust the design formula as needed

# Perform normalization and differential expression analysis
dds <- DESeq(dds)

d <- DESeq2::estimateSizeFactors(dds,type="ratio")
cd <- counts(d,normalized=TRUE)
boxplot(log10(as.matrix(cd)+1),ylab=expression('Log'[10]~'Read counts'),las=2,main="DESeq2 Normalized counts")
```
```{r coorelation heatmap}

# Load required libraries
library(DESeq2)
library(pheatmap)
library(ggplot2)

# Assuming 'dds' is your DESeqDataSet object after normalization
# and 'manifest' is your sample information data frame

# Extract normalized counts
normalized_counts <- counts(dds, normalized=TRUE)

# Calculate sample-to-sample distances
sample_distances <- dist(t(normalized_counts))

# Perform hierarchical clustering
hclust_result <- hclust(sample_distances)

# Create a heatmap of sample distances
pheatmap(as.matrix(sample_distances),
         clustering_distance_rows = sample_distances,
         clustering_distance_cols = sample_distances,
         main = "Sample Distance Heatmap")

# Perform PCA
pca_result <- prcomp(t(normalized_counts))

# Create a data frame for plotting
pca_data <- data.frame(PC1 = pca_result$x[,1],
                       PC2 = pca_result$x[,2],
                       Age_group = manifest$Age_group)

# Plot PCA
ggplot(pca_data, aes(x = PC1, y = PC2, color = Age_group)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "PCA of Normalized Counts",
       x = paste0("PC1: ", round(summary(pca_result)$importance[2,1] * 100, 1), "% variance"),
       y = paste0("PC2: ", round(summary(pca_result)$importance[2,2] * 100, 1), "% variance"))

```
```{r to identify the outlying sample}
# Load required libraries
library(ggplot2)
library(ggrepel)

# Assuming 'pca_result' is your PCA object
# and 'manifest' contains sample information including age group

# Extract PC scores
pc_scores <- as.data.frame(pca_result$x)

# Add sample information
pc_scores$Sample_ID <- rownames(pc_scores)
pc_scores <- merge(pc_scores, manifest, by.x = "Sample_ID", by.y = "Run")

# Calculate the variance explained by each PC
var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2) * 100

# Create the PCA plot
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Age_group, label = Sample_ID)) +
  geom_point(size = 3) +
  geom_text_repel(size = 3, show.legend = FALSE) +
  theme_minimal() +
  labs(title = "PCA Plot of Normalized Counts",
       x = paste0("PC1: ", round(var_explained[1], 1), "% variance"),
       y = paste0("PC2: ", round(var_explained[2], 1), "% variance")) +
  scale_color_brewer(palette = "Set1")

```
```{r checking manifest file for possible batch effect}
# Assuming 'manifest' is your data frame containing the metadata

# Select the relevant columns (RIN and ReleaseDate)
rin_release_data <- manifest[, c("Run", "RIN", "ReleaseDate")]

# Print the data frame to show RIN and ReleaseDate for each sample
print(rin_release_data)

```
```{r removing samle because of its low RNA quality  }

#RIN 7-10: Indicates intact RNA, generally suitable for most applications.
#RIN 6: May be acceptable depending on the specific requirements of the experiment.
#RIN below 6: Often indicates degraded RNA and may not yield reliable results in RNA-seq or other sensitive assays.
# Assuming 'counts' is your counts matrix and 'manifest' is your metadata data frame

# Remove sample SRR2071347 from counts data
refiltered_counts <- filtered_counts[, colnames(filtered_counts) != "SRR2071347"]

# Remove sample SRR2071347 from metadata
refiltered_manifest <- manifest[manifest$Run != "SRR2071347", ]

# Ensure row names of refiltered_manifest match column names of refiltered_counts
rownames(refiltered_manifest) <- refiltered_manifest$Run

# Create DESeqDataSet object with refiltered data
dds <- DESeqDataSetFromMatrix(countData = refiltered_counts,
                              colData = refiltered_manifest,
                              design = ~ Age_group)

# Perform DESeq2 normalization
dds <- DESeq(dds)

# Extract normalized counts
normalized_counts <- counts(dds, normalized = TRUE)

# Perform PCA
pca_result <- prcomp(t(normalized_counts))

# Create a data frame with PCA results and sample information
pca_data <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  Sample = colnames(normalized_counts)
)
pca_data <- merge(pca_data, refiltered_manifest, by.x = "Sample", by.y = "Run")

# Calculate variance explained
var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2) * 100

# Create PCA plot
library(ggplot2)
ggplot(pca_data, aes(x = PC1, y = PC2, color = Age_group, label = Sample)) +
  geom_point(size = 3) +
  geom_text_repel(size = 3, show.legend = FALSE) +
  theme_minimal() +
  labs(title = "PCA Plot of Normalized Counts (Outlier Removed)",
       x = paste0("PC1: ", round(var_explained[1], 1), "% variance"),
       y = paste0("PC2: ", round(var_explained[2], 1), "% variance")) +
  scale_color_brewer(palette = "Set1")

# clustering
# Calculate sample-to-sample distances
sample_distances <- dist(t(normalized_counts))

# Perform hierarchical clustering
hclust_result <- hclust(sample_distances)

# Create a heatmap of sample distances
pheatmap(as.matrix(sample_distances),
         clustering_distance_rows = sample_distances,
         clustering_distance_cols = sample_distances,
         main = "Sample Distance Heatmap")


```
```{r differential gene expression}
# Load required libraries
library(DESeq2)
library(ggplot2)
library(EnhancedVolcano)

# Assuming 'refiltered_counts' is your count matrix and 'refiltered_metadata' is your metadata

# Create DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = refiltered_counts, 
                    colData = refiltered_manifest, 
                    design = ~ Age_group)

# Run DESeq2
dds <- DESeq(dds)

# Get results
res <- results(dds)

# Convert to data frame
res_df <- as.data.frame(res)
res_df$gene <- rownames(res_df)

# Check p-value distribution
hist(res_df$pvalue, breaks = 50, main = "P-value Distribution", xlab = "P-value")

# Q-Q plot
qqnorm(res_df$stat)
qqline(res_df$stat, col = "red")

# Manhattan plot
manhattan_plot <- ggplot(res_df, aes(x = gene, y = -log10(pvalue))) +
  geom_point() +
  theme_minimal() +
  theme(axis.text.x = element_blank()) +
  labs(title = "Manhattan Plot", x = "Genes", y = "-log10(p-value)")

print(manhattan_plot)

# Volcano plot
volcano_plot <- EnhancedVolcano(res_df,
                                lab = res_df$gene,
                                x = 'log2FoldChange',
                                y = 'pvalue',
                                title = 'Volcano Plot',
                                pCutoff = 0.05,
                                FCcutoff = 1,
                                pointSize = 1.5,
                                labSize = 3.0)

print(volcano_plot)

```
```{r visualize individual genes}
# Assuming 'dds' is your DESeqDataSet object

# Extract normalized counts for the genes of interest
genes_of_interest <- c("SOX11", "DCX", "SLC6A1", "NRGN", "CAMK2A")
counts_data <- counts(dds, normalized=TRUE)[genes_of_interest,]

# Convert to long format for plotting
library(reshape2)
counts_long <- melt(counts_data)
colnames(counts_long) <- c("Gene", "Sample", "Normalized_Counts")

# Add age group information
counts_long$Age_group <- refiltered_manifest$Age_group[match(counts_long$Sample, rownames(refiltered_manifest))]

# Create the plot
library(ggplot2)

ggplot(counts_long, aes(x=Age_group, y=Normalized_Counts, fill=Gene)) +
  geom_boxplot() +
  facet_wrap(~Gene, scales="free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Expression of Key Developmental Genes Across Age Groups",
       x = "Age Group",
       y = "Normalized Counts") +
  scale_fill_brewer(palette = "Set1")

```

